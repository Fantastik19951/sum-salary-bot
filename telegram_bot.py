import os
import logging
import datetime as dt
import re
from collections import defaultdict, deque

from dotenv import load_dotenv
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, Message
from telegram import __version__ as TG_VER
from telegram.ext import (
    ApplicationBuilder, CommandHandler,
    CallbackQueryHandler, MessageHandler,
    ContextTypes, filters
)
import gspread
from oauth2client.service_account import ServiceAccountCredentials

# ‚îÄ‚îÄ‚îÄ CONFIG & LOGGING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
load_dotenv()
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
GOOGLE_KEY_JSON = os.getenv("GOOGLE_KEY_JSON")
if not TOKEN:
    raise RuntimeError("TELEGRAM_BOT_TOKEN must be set")
if GOOGLE_KEY_JSON and not os.path.exists("credentials.json"):
    with open("credentials.json", "w", encoding="utf-8") as f:
        f.write(GOOGLE_KEY_JSON)

logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s | %(levelname)s | %(message)s")
logger = logging.getLogger(__name__)

DATE_FMT     = "%d.%m.%Y"
DATE_RX      = re.compile(r"\d{2}\.\d{2}\.\d{4}$")
HEADER_ROWS  = 4
UNDO_WINDOW  = 10      # seconds for undo
REMIND_HH_MM = (20, 0) # daily reminder at 20:00
MONTH_NAMES  = [
    "—è–Ω–≤–∞—Ä—å","—Ñ–µ–≤—Ä–∞–ª—å","–º–∞—Ä—Ç","–∞–ø—Ä–µ–ª—å","–º–∞–π","–∏—é–Ω—å",
    "–∏—é–ª—å","–∞–≤–≥—É—Å—Ç","—Å–µ–Ω—Ç—è–±—Ä—å","–æ–∫—Ç—è–±—Ä—å","–Ω–æ—è–±—Ä—å","–¥–µ–∫–∞–±—Ä—å"
]

# PAD: –¥–≤–µ –Ω–µ—Ä–∞–∑—Ä—ã–≤–Ω—ã—Ö –ø—Ä–æ–±–µ–ª—ã
# –í–∏–∑—É–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
SEPARATOR = "‚ñ¨" * 30
PAD = "\u00A0" * 2  # –ù–µ—Ä–∞–∑—Ä—ã–≤–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
ICONS = {
    "high": "üöÄ",
    "medium": "üî•",
    "low": "‚≠ê",
    "default": "üî∏"
}

# ‚îÄ‚îÄ‚îÄ GOOGLE SHEETS I/O ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def connect_sheet():
    scope = [
        "https://spreadsheets.google.com/feeds",
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive.file",
        "https://www.googleapis.com/auth/drive",
    ]
    creds = ServiceAccountCredentials.from_json_keyfile_name("credentials.json", scope)
    return gspread.authorize(creds).open("TelegramBotData").sheet1

try:
    SHEET = connect_sheet()
    logging.info("Connected to Google Sheet")
except Exception as e:
    logging.error(f"Sheets connection failed: {e}")
    SHEET = None

def safe_float(s: str):
    try: return float(s.replace(",","."))
    except: return None

def sdate(d: dt.date) -> str: return d.strftime(DATE_FMT)
def pdate(s: str) -> dt.date: return dt.datetime.strptime(s, DATE_FMT).date()
def is_date(s: str) -> bool: return bool(DATE_RX.fullmatch(s.strip()))

def read_sheet():
    data = defaultdict(list)
    if not SHEET: return data
    for idx,row in enumerate(SHEET.get_all_values(), start=1):
        if idx <= HEADER_ROWS or len(row)<2: continue
        d=row[0].strip()
        if not is_date(d): continue
        amt = safe_float(row[2]) if len(row)>2 else None
        sal = safe_float(row[3]) if len(row)>3 else None
        if amt is None and sal is None: continue
        e={"date":d,"symbols":row[1].strip(),"row_idx":idx}
        if sal is not None: e["salary"]=sal
        else:                e["amount"]=amt
        key=f"{pdate(d).year}-{pdate(d).month:02d}"
        data[key].append(e)
    return data

def push_row(entry):
    if not SHEET: return None
    nd = pdate(entry["date"])
    row = [entry["date"], entry.get("symbols",""),
           entry.get("amount",""), entry.get("salary","")]
    col = SHEET.col_values(1)[HEADER_ROWS:]
    ins=HEADER_ROWS
    for i,v in enumerate(col, start=HEADER_ROWS+1):
        try:
            if pdate(v)<=nd: ins=i
            else: break
        except: continue
    SHEET.insert_row(row, ins+1, value_input_option="USER_ENTERED")
    return ins+1

def update_row(idx:int, symbols:str, amount:float):
    if not SHEET: return
    SHEET.update_cell(idx,2,symbols)
    SHEET.update_cell(idx,3,amount)

def delete_row(idx:int):
    if SHEET: SHEET.delete_rows(idx)

# ‚îÄ‚îÄ‚îÄ SYNC & REMINDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def auto_sync(ctx):
    ctx.application.bot_data["entries"] = read_sheet()

async def reminder(ctx):
    for cid in ctx.application.bot_data.get("chats", set()):
        try: await ctx.bot.send_message(cid,"‚è∞ –ù–µ –∑–∞–±—É–¥—å—Ç–µ –≤–Ω–µ—Å—Ç–∏ –∑–∞–ø–∏—Å–∏ —Å–µ–≥–æ–¥–Ω—è!")
        except: pass

# ‚îÄ‚îÄ‚îÄ NAV STACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def init_nav(ctx):
    ctx.user_data["nav"] = deque([("main","–ì–ª–∞–≤–Ω–æ–µ")])

def push_nav(ctx,code,label):
    ctx.user_data.setdefault("nav",deque()).append((code,label))

def pop_view(ctx):
    nav = ctx.user_data.get("nav",deque())
    if len(nav)>1: nav.pop()
    return nav[-1]

def peek_prev(ctx):
    nav = ctx.user_data.get("nav",deque())
    return nav[-2] if len(nav)>=2 else nav[-1]

# ¬´–ù–∞–∑–∞–¥¬ª+¬´–ì–ª–∞–≤–Ω–æ–µ¬ª –¥–ª—è –¥–Ω–µ–π/–º–µ—Å—è—Ü–µ–≤/–≥–æ–¥–æ–≤
def nav_kb(ctx):
    prev_code, prev_label = peek_prev(ctx)
    return InlineKeyboardMarkup([[
        InlineKeyboardButton(f"‚¨ÖÔ∏è {prev_label}", callback_data="back"),
        InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ", callback_data="main")
    ]])

# —Ç–æ–ª—å–∫–æ ¬´–ì–ª–∞–≤–Ω–æ–µ¬ª –¥–ª—è KPI –∏ –ò—Å—Ç–æ—Ä–∏–∏
MAIN_ONLY_KB = InlineKeyboardMarkup([[
    InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ", callback_data="main")
]])

# ‚îÄ‚îÄ‚îÄ UI & FORMAT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def fmt_amount(x: float) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É–º–º—ã —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏"""
    if abs(x - int(x)) < 1e-9:
        return f"{int(x):,}".replace(",", ".")
    s = f"{x:.2f}".rstrip("0").rstrip(".")
    i, f = (s.split(".") if "." in s else (s, ""))
    return f"{int(i):,}".replace(",", ".") + (f and "," + f)
    
def get_amount_icon(amount: float) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–∫–æ–Ω–∫—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—É–º–º—ã"""
    if amount > 2000: return ICONS["high"]
    elif amount > 1000: return ICONS["medium"]
    elif amount > 500: return ICONS["low"]
    return ICONS["default"]
    
def bounds_today():
    d=dt.date.today()
    return (d.replace(day=1) if d.day<=15 else d.replace(day=16)), d

def bounds_prev():
    d=dt.date.today()
    if d.day<=15:
        last = d.replace(day=1)-dt.timedelta(days=1)
        return (last.replace(day=16), last)
    return (d.replace(day=1), d.replace(day=15))

async def safe_edit(msg:Message, text:str, kb:InlineKeyboardMarkup):
    try:    return await msg.edit_text(text, parse_mode="HTML", reply_markup=kb)
    except: return await msg.reply_text(text, parse_mode="HTML", reply_markup=kb)

# ‚îÄ‚îÄ‚îÄ KEYBOARDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def main_kb():
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(f"{PAD*2}üìÖ¬†2024{PAD*2}", callback_data="year_2024"),
            InlineKeyboardButton(f"{PAD*2}üìÖ¬†2025{PAD*2}", callback_data="year_2025"),
        ],
        [ InlineKeyboardButton(f"{PAD*2}üìÜ¬†–°–µ–≥–æ–¥–Ω—è{PAD*2}", callback_data="go_today") ],
        [ InlineKeyboardButton(f"{PAD*2}‚ûï¬†–ó–∞–ø–∏—Å—å{PAD*2}",  callback_data="add_rec") ],
        [ InlineKeyboardButton(f"{PAD*5}üí∞¬†–¢–µ–∫—É—â–∞—è¬†–ó–ü{PAD*10}", callback_data="profit_now"),
          InlineKeyboardButton(f"{PAD*5}üíº¬†–ü—Ä–æ—à–ª–∞—è¬†–ó–ü{PAD*10}", callback_data="profit_prev") ],
        [ InlineKeyboardButton(f"{PAD*2}üìú¬†–ò—Å—Ç–æ—Ä–∏—è¬†–ó–ü{PAD*2}", callback_data="hist") ],
        [ InlineKeyboardButton(f"{PAD*2}üìä¬†KPI¬†—Ç–µ–∫.{PAD*2}", callback_data="kpi"),
          InlineKeyboardButton(f"{PAD*2}üìä¬†KPI¬†–ø—Ä–æ—à.{PAD*2}", callback_data="kpi_prev") ],
    ])

# ‚îÄ‚îÄ‚îÄ VIEWS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def show_main(msg, ctx, push=True):
    if push: init_nav(ctx)
    ctx.application.bot_data.setdefault("chats", set()).add(msg.chat_id)
    ctx.application.bot_data["entries"] = read_sheet()
    
    # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    today = dt.date.today()
    current_month = f"{today.year}-{today.month:02d}"
    entries = ctx.application.bot_data["entries"].get(current_month, [])
    month_total = sum(e.get('amount', 0) for e in entries)
    
    text = f"""
    {PAD*2}{SEPARATOR}
                    üè† <b>–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ</b>
    {SEPARATOR}
    
    üìÖ –¢–µ–∫—É—â–∏–π –º–µ—Å—è—Ü: {MONTH_NAMES[today.month-1].capitalize()}
    üí∞ –°—É–º–º–∞—Ä–Ω—ã–π –æ–±–æ—Ä–æ—Ç: {fmt_amount(month_total)} $
    üìà –ó–∞—Ä–∞–±–æ—Ç–æ–∫ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è: {fmt_amount(month_total * 0.1)} $
    """
    await safe_edit(msg, text, main_kb())
    
async def show_year(msg,ctx,year,push=True):
    if push: push_nav(ctx, f"year_{year}", year)
    btns = [
        InlineKeyboardButton(MONTH_NAMES[i].capitalize(), callback_data=f"mon_{year}-{i+1:02d}")
        for i in range(12)
    ]
    rows = [btns[i:i+4] for i in range(0,12,4)]
    rows.extend(nav_kb(ctx).inline_keyboard)
    await safe_edit(msg, f"<b>{PAD*15}üìÜ¬†{year}</b>", InlineKeyboardMarkup(rows))
    

async def show_month(msg,ctx,code,flag=None,push=True):
    y,m = code.split("-")
    label = f"{MONTH_NAMES[int(m)-1].capitalize()}¬†{y}"
    if push: push_nav(ctx, f"mon_{code}", label)
    td=dt.date.today()
    if flag is None:
        flag = "old" if td.strftime("%Y-%m")==code and td.day<=15 else "new"
    ents = ctx.application.bot_data["entries"].get(code,[])
    part = [e for e in ents if "amount" in e and ((pdate(e["date"]).day<=15)==(flag=="old"))]
    days = sorted({e["date"] for e in part}, key=pdate)
    total = sum(e["amount"] for e in part)
    hdr = f"<b>{label}¬†¬∑¬†{'01‚Äì15' if flag=='old' else '16‚Äì31'}</b>"
    body = "\n".join(
        f"{d}¬†¬∑¬†{fmt_amount(sum(x['amount'] for x in part if x['date']==d))}¬†$"
        for d in days
    ) or "–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π"
    ftr = f"<b>–ò—Ç–æ–≥–æ:¬†{fmt_amount(total)}¬†$</b>"
    tog = "new" if flag=="old" else "old"
    rows = [[ InlineKeyboardButton(
        "–ü–µ—Ä–≤–∞—è¬†–ø–æ–ª–æ–≤–∏–Ω–∞" if flag=="old" else "–í—Ç–æ—Ä–∞—è¬†–ø–æ–ª–æ–≤–∏–Ω–∞",
        callback_data=f"tgl_{code}_{tog}"
    )]]
    for d in days:
        rows.append([InlineKeyboardButton(d, callback_data=f"day_{code}_{d}")])
    rows.extend(nav_kb(ctx).inline_keyboard)
    await safe_edit(msg, "\n".join([hdr,body,"",ftr]), InlineKeyboardMarkup(rows))

async def show_day(msg, ctx, code, date, push=True):
    if push: 
        push_nav(ctx, f"day_{code}_{date}", date)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏ –ø–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å–∏
    ctx.application.bot_data["entries"] = read_sheet()
    ents = [e for e in ctx.application.bot_data["entries"].get(code, []) 
            if e["date"] == date and "amount" in e]
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
    header = f"""
    {PAD*2}{SEPARATOR}
                    üóìÔ∏è <b>{date}</b>
    {SEPARATOR}
    """
    
    # –¢–µ–ª–æ —Å –∏–∫–æ–Ω–∫–∞–º–∏
    body = "\n".join(
        f"{get_amount_icon(e['amount'])} {i+1}. {e['symbols']} ¬∑ {fmt_amount(e['amount'])} $"
        for i, e in enumerate(ents)
    ) or "üì≠ –ù–µ—Ç –∑–∞–ø–∏—Å–µ–π"
    
    # –ü–æ–¥–≤–∞–ª —Å –∏—Ç–æ–≥–∞–º–∏
    total = sum(e["amount"] for e in ents)
    footer = f"""
    {SEPARATOR}
     <b>{PAD*5}üí∞ –ò—Ç–æ–≥–æ:</b> {fmt_amount(total)} $
     <i>{PAD*5}üìä –°—Ä–µ–¥–Ω–µ–µ: {fmt_amount(total/len(ents)) if ents else 0} $/–∑–∞–ø–∏—Å—å</i>
    """
    
    # –ö–Ω–æ–ø–∫–∏
    rows = []
    for i, e in enumerate(ents):
        rows.append([
            InlineKeyboardButton(f"‚ùå{i+1}", callback_data=f"confirm_del_{e['row_idx']}_{code}_{date}"),
            InlineKeyboardButton(f"‚úèÔ∏è{i+1}", callback_data=f"edit_{e['row_idx']}_{code}_{date}")
        ])
    rows.append([InlineKeyboardButton("‚ûï –ó–∞–ø–∏—Å—å", callback_data=f"add_{code}_{date}")])
    rows.extend(nav_kb(ctx).inline_keyboard)
    
    await safe_edit(msg, "\n".join([header, body, footer]), InlineKeyboardMarkup(rows))
    
async def show_history(msg, ctx, push=True):
    ctx.application.bot_data["entries"] = read_sheet()
    ents = [e for v in ctx.application.bot_data["entries"].values() 
            for e in v if "salary" in e]
    
    header = f"""
    {SEPARATOR}
    üìú <b>–ò–°–¢–û–†–ò–Ø –í–´–ü–õ–ê–¢ –ó–ü</b>
    {SEPARATOR}
    """
    
    if not ents:
        text = header + "\nüì≠ –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –≤—ã–ø–ª–∞—Ç–∞—Ö"
    else:
        lines = [
            f"‚ñ´Ô∏è {pdate(e['date']).day} {MONTH_NAMES[pdate(e['date']).month-1]} {pdate(e['date']).year} ¬∑ {fmt_amount(e['salary'])} $"
            for e in sorted(ents, key=lambda x: pdate(x['date']))
        ]
        text = header + "\n".join(lines)
    
    await safe_edit(msg, text, MAIN_ONLY_KB)
    
async def show_profit(msg,ctx,start,end,title,push=True):
    if push: push_nav(ctx,title,title)
    ents = [e for v in ctx.application.bot_data["entries"].values() for e in v
            if start<=pdate(e['date'])<=end and "amount" in e]
    tot = sum(e["amount"] for e in ents)
    text = f"{title}¬†({sdate(start)}‚Äì{sdate(end)})\n<b>10%:¬†{fmt_amount(tot*0.10)}¬†$</b>"
    await safe_edit(msg, text, MAIN_ONLY_KB)

import calendar

def progress_bar(progress: float) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä"""
    bars = int(progress * 10)
    return "üü©" * bars + "‚¨úÔ∏è" * (10 - bars)

async def show_kpi(msg, ctx, prev=False, push=True):
    # 1) –ì—Ä–∞–Ω–∏—Ü—ã "–∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–æ–≥–æ" –ø–µ—Ä–∏–æ–¥–∞ (–¥–ª—è prev) –∏–ª–∏ "–∞–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ" –Ω–∞—á–∞–ª–∞
    if prev:
        start, end = bounds_prev()
        title = "üìä KPI –ø—Ä–æ—à–ª–æ–≥–æ"
        period_end = end
    else:
        start_actual, today = bounds_today()
        title = "üìä KPI —Ç–µ–∫—É—â–µ–≥–æ"
        # –î–ª—è —Ä–∞—Å—á—ë—Ç–∞ filled_days –æ—Ç—Ä–µ–∑–∞–µ–º –¥–æ today:
        start, end = start_actual, today
        # –ê –¥–ª—è total_days –∏ –ø—Ä–æ–≥–Ω–æ–∑–∞:
        y, m = start.year, start.month
        if start.day == 1:
            # –ø–µ—Ä–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞
            period_end = dt.date(y, m, 15)
        else:
            # –≤—Ç–æ—Ä–∞—è ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å –º–µ—Å—è—Ü–∞
            last_day = calendar.monthrange(y, m)[1]
            period_end = dt.date(y, m, last_day)

    if push and not prev:
        push_nav(ctx, title, title)

    # 2) –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–±–æ—Ä–æ—Ç—ã (amount) –¥–æ today (–¥–ª—è prev ‚Äî –¥–æ end)
    entries = [
        e for v in ctx.application.bot_data["entries"].values() for e in v
        if start <= pdate(e["date"]) <= end and "amount" in e
    ]
    if not entries:
        return await safe_edit(msg, "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö", MAIN_ONLY_KB)

    # 3) –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
    turnover = sum(e["amount"] for e in entries)
    salary   = turnover * 0.10

    # 4) –°–∫–æ–ª—å–∫–æ **—Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏** –¥–Ω–µ–π –∑–∞–ø–æ–ª–Ω–µ–Ω–æ:
    filled_days = len({e["date"] for e in entries})

    # 5) –ü–æ–ª–Ω–æ–µ —á–∏—Å–ª–æ –¥–Ω–µ–π –≤ –ø–µ—Ä–∏–æ–¥–µ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞:
    total_days = (period_end - start).days + 1

    # 6) –°—Ä–µ–¥–Ω–µ–µ –∑–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –¥–Ω–∏:
    avg_per_day = salary / filled_days if filled_days else 0

    # 7) –ü—Ä–æ–≥–Ω–æ–∑:
    forecast = None if prev else avg_per_day * total_days
    
    progress = filled_days / total_days if total_days else 0
    progress_visual = f"\n{progress_bar(progress)} {int(progress*100)}%"

    # 8) –°–æ–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç
    header = f"{title} ({sdate(start)} ‚Äì {sdate(period_end)})"
    parts = [
        f"üíµ –û–±–æ—Ä–æ—Ç: {fmt_amount(turnover)} $",
        f"üí∞ –ó–∞—Ä–ø–ª–∞—Ç–∞ (10%): {fmt_amount(salary)} $",
        f"üìÜ –ó–∞–ø–æ–ª–Ω–µ–Ω–æ –¥–Ω–µ–π: {filled_days}/{total_days}",
        f"üìà –°—Ä–µ–¥–Ω–µ–µ/–¥–µ–Ω—å: {fmt_amount(avg_per_day)} $",
        progress_visual
    ]
    
    if forecast is not None:
        parts += ["", f"<b>–ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –∫–æ–Ω–µ—Ü –ø–µ—Ä–∏–æ–¥–∞:</b> {fmt_amount(forecast)} $"]

    text = "\n".join(parts)

    # 9) –î–ª—è KPI ‚Äî —Ç–æ–ª—å–∫–æ –∫–Ω–æ–ø–∫–∞ ¬´–ì–ª–∞–≤–Ω–æ–µ¬ª
    await safe_edit(msg, f"{header}\n\n{text}", MAIN_ONLY_KB)
# ‚îÄ‚îÄ‚îÄ ADD/EDIT FLOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def ask_date(msg, ctx):
    """–ù–æ–≤—ã–π –¥–∏–∑–∞–π–Ω –≤–≤–æ–¥–∞ –¥–∞—Ç—ã"""
    text = f"""
    {SEPARATOR}
    üìÖ <b>–î–û–ë–ê–í–õ–ï–ù–ò–ï –ó–ê–ü–ò–°–ò</b>
    {SEPARATOR}
    –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì 
    –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ:
    """
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìÜ –°–µ–≥–æ–¥–Ω—è", callback_data="today_add")],
        [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    
    prompt = await msg.reply_text(text, parse_mode="HTML", reply_markup=keyboard)
    ctx.user_data["flow"] = {"step": "date", "msg": msg, "prompt": prompt}
    
async def ask_name(msg,ctx):
    flow = ctx.user_data["flow"]
    if flow.get("mode")=="edit":
        prompt = await msg.reply_text(f"‚úèÔ∏è¬†–í–≤–µ–¥–∏—Ç–µ –∏–º—è¬†(—Å—Ç–∞—Ä–æ–µ:¬†{flow['old_symbols']}):")
    else:
        prompt = await msg.reply_text("‚úèÔ∏è¬†–í–≤–µ–¥–∏—Ç–µ –∏–º—è:")
    flow.update({"step":"sym","prompt":prompt})

async def ask_amount(msg,ctx):
    flow = ctx.user_data["flow"]
    if flow.get("mode")=="edit":
        prev = flow["old_amount"]
        prompt = await msg.reply_text(f"üí∞¬†–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É¬†(—Å—Ç–∞—Ä–æ–µ:¬†{fmt_amount(prev)}¬†$):")
    else:
        prompt = await msg.reply_text("üí∞¬†–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É:")
    flow.update({"step":"val","prompt":prompt})

# ‚îÄ‚îÄ‚îÄ ADD/EDIT FLOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def process_text(u: Update, ctx: ContextTypes.DEFAULT_TYPE):
    flow = ctx.user_data.get("flow")
    if not flow:
        return

    logger.info(f"process_text step={flow['step']} mode={flow.get('mode')}")
    txt = u.message.text.strip()
    await u.message.delete()
    try:
        await flow["prompt"].delete()
    except:
        pass

    if flow["step"] == "date":
        if txt.lower() == "—Å–µ–≥–æ–¥–Ω—è":
            flow["date"] = sdate(dt.date.today())
        elif is_date(txt):
            flow["date"] = txt
        else:
            return await flow["msg"].reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã")
        return await ask_name(flow["msg"], ctx)

    if flow["step"] == "sym":
        flow["symbols"] = txt
        return await ask_amount(flow["msg"], ctx)

    if flow["step"] == "val":
        try:
            val = float(txt.replace(",", "."))
        except:
            return await flow["msg"].reply_text("–ù—É–∂–Ω–æ —á–∏—Å–ª–æ")

        dt_obj = pdate(flow["date"])
        period = f"{dt_obj.year}-{dt_obj.month:02d}"
        date_str = flow["date"]
        formatted_date = f"{dt_obj.day} {MONTH_NAMES[dt_obj.month-1]} {dt_obj.year} –≥–æ–¥–∞"

        if flow.get("mode") == "edit":
            idx = flow["row"]
            update_row(idx, flow["symbols"], val)
            ctx.application.bot_data["entries"] = read_sheet()
            
            # –°–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π –æ—Ç–º–µ–Ω—ã
            success_msg = await flow["msg"].reply_text(
                f"‚úèÔ∏è –ò–∑–º–µ–Ω–µ–Ω–æ: {flow['symbols']} ¬∑ {fmt_amount(val)} $\n"
                f"‚ñ´Ô∏è –î–∞—Ç–∞: {formatted_date}\n"
                f"‚åõ –°–æ–æ–±—â–µ–Ω–∏–µ –∏—Å—á–µ–∑–Ω–µ—Ç —á–µ—Ä–µ–∑ {UNDO_WINDOW} —Å–µ–∫—É–Ω–¥",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("‚Ü∫ –û—Ç–º–µ–Ω–∏—Ç—å", callback_data=f"undo_edit_{idx}")
                ]])
            )
            
            ctx.user_data["undo_edit"] = {
                "row": idx,
                "old_symbols": flow["old_symbols"],
                "old_amount": flow["old_amount"],
                "period": period,
                "date": date_str,
                "msg": flow["msg"],
                "expires": dt.datetime.utcnow() + dt.timedelta(seconds=UNDO_WINDOW)
            }
            
            # –ê–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
            ctx.application.job_queue.run_once(
                lambda c: c.bot.delete_message(success_msg.chat_id, success_msg.message_id),
                UNDO_WINDOW
            )
            ctx.user_data.pop("flow")
            return await show_day(flow["msg"], ctx, period, date_str)

        else:
            flow["amount"] = val
            row = push_row(flow)
            ctx.application.bot_data["entries"] = read_sheet()
            await show_day(flow["msg"], ctx, period, date_str)

            # –ï–¥–∏–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π –æ—Ç–º–µ–Ω—ã
            resp = await flow["msg"].reply_text(
                f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: {flow['symbols']} ¬∑ {fmt_amount(val)} $\n"
                f"‚ñ´Ô∏è –î–∞—Ç–∞: {formatted_date}\n"
                f"‚åõ –°–æ–æ–±—â–µ–Ω–∏–µ –∏—Å—á–µ–∑–Ω–µ—Ç —á–µ—Ä–µ–∑ {UNDO_WINDOW} —Å–µ–∫—É–Ω–¥",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("‚Ü∫ –û—Ç–º–µ–Ω–∏—Ç—å", callback_data=f"undo_{row}")
                ]])
            )

            ctx.user_data["undo"] = {
                "row": row,
                "msg": flow["msg"],
                "period": period,
                "date": date_str,
                "expires": dt.datetime.utcnow() + dt.timedelta(seconds=UNDO_WINDOW)
            }

            ctx.application.job_queue.run_once(
                lambda c: c.bot.delete_message(resp.chat_id, resp.message_id),
                UNDO_WINDOW
            )
            ctx.user_data.pop("flow")
            return
# ‚îÄ‚îÄ‚îÄ CALLBACK HANDLER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def cb(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    q = upd.callback_query
    if not q:
        return
    await q.answer()
    d, msg = q.data, q.message
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —É–¥–∞–ª–µ–Ω–∏—è
    if d.startswith("confirm_del_"):
        _, _, row_idx, code, date = d.split("_", 4)
        delete_row(int(row_idx))
        ctx.application.bot_data["entries"] = read_sheet()
        await msg.delete()  # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
        return await show_day(msg, ctx, code, date)
    
    # –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ callback'–æ–≤...
    if d == "add_rec":
        return await ask_date(msg, ctx)

    if d=="main":
        return await show_main(msg, ctx)

    if d=="back":
        code,label = pop_view(ctx)
        if code=="main":
            return await show_main(msg,ctx,push=False)
        if code.startswith("year_"):
            return await show_year(msg,ctx,code.split("_",1)[1],push=False)
        if code.startswith("mon_"):
            return await show_month(msg,ctx,code.split("_",1)[1],None,push=False)
        if code.startswith("day_"):
            _,c,dd = code.split("_",2)
            return await show_day(msg,ctx,c,dd,push=False)
        return await show_main(msg,ctx,push=False)

    if d=="go_today":
        ctx.application.bot_data["entries"] = read_sheet()
        td = dt.date.today()
        return await show_day(msg,ctx, f"{td.year}-{td.month:02d}", sdate(td))

    if d.startswith("year_"):
        return await show_year(msg,ctx, d.split("_",1)[1])

    if d.startswith("mon_"):
        _,code = d.split("_",1)
        return await show_month(msg,ctx,code)

    if d.startswith("tgl_"):
        _,code,fl = d.split("_",2)
        return await show_month(msg,ctx,code,fl)

    if d.startswith("day_"):
        _,code,day = d.split("_",2)
        return await show_day(msg,ctx,code,day)

    if d.startswith("add_"):
        parts = d.split("_")          # ['add','2025-05','12.05.2025']
        code  = parts[1]
        date  = parts[2]
        ctx.user_data["flow"] = {
            "step":   "sym",
            "mode":   "add",
            "date":   date,
            "period": code,
            "msg":    msg
        }
        return await ask_name(msg, ctx)
    
    if d.startswith("drow_"):
        _,r,c,dd = d.split("_",4)[:4]
        delete_row(int(r))
        ctx.application.bot_data["entries"] = read_sheet()
        return await show_day(msg,ctx,c,dd)

    if d.startswith("edit_"):
        _,r,code,day = d.split("_",3)
        idx = int(r)
        old = next(e for e in ctx.application.bot_data["entries"][code] if e["row_idx"]==idx)
        ctx.user_data["flow"] = {
            "step":"sym","mode":"edit","row":idx,
            "date":day,"period":code,
            "old_symbols":old["symbols"],"old_amount":old["amount"],
            "msg":msg
        }
        return await ask_name(msg,ctx)

    if d.startswith("undo_edit_"):
        ud = ctx.user_data.get("undo_edit", {})
        parts = d.split("_")
        idx = int(parts[2])  # –Ω–æ–º–µ—Ä —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ–π —Å—Ç—Ä–æ–∫–∏
        # –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Ç–∞ –∂–µ —Å–∞–º–∞—è –æ—Ç–º–µ–Ω–∞ –∏ –Ω–µ –≤—ã—à–ª–æ –≤—Ä–µ–º—è
        if ud.get("row") == idx and dt.datetime.utcnow() <= ud.get("expires"):
            # —É–¥–∞–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ "‚úÖ –ò–∑–º–µ–Ω–µ–Ω–æ"
            await q.message.delete()
            # –æ—Ç–∫–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Ç–∞–±–ª–∏—Ü–µ
            update_row(idx, ud["old_symbols"], ud["old_amount"])
            ctx.application.bot_data["entries"] = read_sheet()
            # –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π –¥–µ–Ω—å –≤ —Ç–æ–º –∂–µ —Å–æ–æ–±—â–µ–Ω–∏–∏
            return await show_day(ud["msg"], ctx, ud["period"], ud["date"])
        else:
            return await q.message.reply_text("‚è± –í—Ä–µ–º—è –≤—ã—à–ª–æ")

    # ‚îÄ‚îÄ‚îÄ –û–¢–ú–ï–ù–ê –î–û–ë–ê–í–õ–ï–ù–ò–Ø ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if d.startswith("undo_"):
        ud = ctx.user_data.get("undo", {})
        now = dt.datetime.utcnow()
        if ud and d == f"undo_{ud['row']}" and now <= ud["expires"]:
            # —É–¥–∞–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            await msg.delete()
            # —É–¥–∞–ª—è–µ–º —Å—Ç—Ä–æ–∫—É
            delete_row(ud["row"])
            ctx.application.bot_data["entries"] = read_sheet()
            # –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Ç–æ –∂–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–Ω—è —Å –æ—Ç–∫–∞—Ç–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            return await show_day(ud["msg"], ctx, ud["period"], ud["date"])
        else:
            return await msg.reply_text("‚è± –í—Ä–µ–º—è –≤—ã—à–ª–æ")
            
    if d=="profit_now":
        s,e = bounds_today()
        return await show_profit(msg,ctx,s,e,"üí∞¬†–¢–µ–∫—É—â–∞—è¬†–ó–ü")

    if d=="profit_prev":
        s,e = bounds_prev()
        return await show_profit(msg,ctx,s,e,"üíº¬†–ü—Ä–æ—à–ª–∞—è¬†–ó–ü")

    if d=="hist":
        return await show_history(msg,ctx)

    if d=="kpi":
        return await show_kpi(msg,ctx,False)

    if d=="kpi_prev":
        return await show_kpi(msg,ctx,True)
        
    # –í —Ñ—É–Ω–∫—Ü–∏–∏ cb –¥–æ–±–∞–≤—å—Ç–µ:
    elif d.startswith("cancel_del_"):
        _, _, code, date = d.split("_", 3)
        await msg.delete()  # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
        return await show_day(msg, ctx, code, date)

async def error_handler(update, context):
    logging.error(f"Unhandled exception {update!r}", exc_info=context.error)

async def cmd_start(update:Update,ctx:ContextTypes.DEFAULT_TYPE):
    ctx.application.bot_data = {"entries":read_sheet(),"chats":set()}
    await update.message.reply_text(
        "üìä¬†<b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=main_kb()
    )
    ctx.application.bot_data["chats"].add(update.effective_chat.id)

async def on_startup(app):
    # —É–¥–∞–ª—è–µ–º –≤—Å–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ slash-–∫–æ–º–∞–Ω–¥—ã
    await app.bot.set_my_commands([])

if __name__=="__main__":
    app = (
        ApplicationBuilder()
        .token(TOKEN)
        .post_init(on_startup)    # <-- —Å—é–¥–∞ –≤–µ—à–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –æ—á–∏—Å—Ç–∫–∏ –∫–æ–º–∞–Ω–¥
        .build()
    )
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CallbackQueryHandler(cb))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, process_text))
    app.add_error_handler(error_handler)

    app.job_queue.run_repeating(auto_sync, interval=5, first=0)
    hh, mm = REMIND_HH_MM
    app.job_queue.run_daily(reminder, time=dt.time(hour=hh, minute=mm))

    logging.info("üöÄ Bot up")
    app.run_polling(drop_pending_updates=True)